#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# This file is part of urlwatch (https://thp.io/2008/urlwatch/).
# Copyright (c) 2008-2016 Thomas Perl <thp.io/about>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. The name of the author may not be used to endorse or promote products
#    derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# File and folder paths
import argparse

import imp
import logging
import os
import os.path
import shutil
import socket
import subprocess
import sys

import requests

class Config(object):

    def __init__(self):

        # Duplicated here
        self.pkgname = 'urlwatch'

        self.urlwatch_dir = os.path.expanduser(os.path.join('~', '.' + self.pkgname))
        self.urls_txt = os.path.join(self.urlwatch_dir, 'urls.txt')
        self.urls_yaml = os.path.join(self.urlwatch_dir, 'urls.yaml')
        self.config_yaml = os.path.join(self.urlwatch_dir, 'urlwatch.yaml')
        self.cache_dir = os.path.join(self.urlwatch_dir, 'cache')
        self.cache_db = os.path.join(self.urlwatch_dir, 'cache.db')
        self.hooks_py = os.path.join(self.urlwatch_dir, 'hooks.py')

        # Check if we are installed in the system already
        (self.prefix, self.bindir) = os.path.split(os.path.dirname(os.path.abspath(sys.argv[0])))

    def setup(self):

        if self.bindir == 'bin':
            # Installed system-wide
            examples_dir = os.path.join(self.prefix, 'share', self.pkgname, 'examples')
        else:
            # Assume we are not yet installed
            sys.path.insert(0, os.path.join(self.prefix, self.bindir, 'lib'))
            examples_dir = os.path.join(self.prefix, self.bindir, 'share', self.pkgname, 'examples')

        self.urls_yaml_example = os.path.join(examples_dir, 'urls.yaml.example')
        self.hooks_py_example = os.path.join(examples_dir, 'hooks.py.example')

urlwatch_config = Config()
urlwatch_config.setup()

# Code section
import urlwatch

from urlwatch.handler import JobState, Report

from urlwatch.storage import UrlsYaml, UrlsTxt, ConfigStorage, CacheDirStorage, CacheMiniDBStorage

from urlwatch.jobs import JobBase, NotModifiedError
from urlwatch.filters import FilterBase
from urlwatch.reporters import ReporterBase
from urlwatch.migration import MigrationManager
from urlwatch.console import edit_hooks, edit_yaml, show_features
from urlwatch.worker import run_parallel

# One minute (=60 seconds) timeout for each request to avoid hanging
socket.setdefaulttimeout(60)

logger = logging.getLogger(urlwatch_config.pkgname)

class Urlwatch:


    def execute_jobs(self):

        logger.debug('Processing %d jobs', len(self.jobs))
        for job_state in run_parallel(lambda job_state: job_state.process(),
                                      (JobState(self.cache_storage, job) for job in self.jobs)):
            logger.debug('Job finished: %s', job_state.job)

            if job_state.exception is not None:
                if isinstance(job_state.exception, NotModifiedError):
                    logger.info('Job %s has not changed (HTTP 304)', job_state.job)
                    self.report.unchanged(job_state)
                elif isinstance(job_state.exception, requests.exceptions.RequestException):
                    # Instead of a full traceback, just show the HTTP error
                    job_state.traceback = str(job_state.exception)
                    self.report.error(job_state)
                else:
                    self.report.error(job_state)
            elif job_state.old_data is not None:
                if job_state.old_data.splitlines() != job_state.new_data.splitlines():
                    self.report.changed(job_state)
                    job_state.save()
                else:
                    self.report.unchanged(job_state)
            else:
                self.report.new(job_state)
                job_state.save()

    def handle_actions(self):

        if self.args.features:
            sys.exit(self.show_features())
        if self.args.gc_cache:
            self.cache_storage.gc([job.get_guid() for job in self.jobs])
            sys.exit(0)
        if self.args.edit:
            sys.exit(edit_yaml(self.args.urls, UrlsYaml, self.config.urls_yaml_example))
        if self.args.edit_hooks:
            sys.exit(edit_hooks(self.args.hooks, self.config.hooks_py_example))
        if self.args.list:
            sys.exit(self.list_urls(self.jobs, self.args.verbose))
        if self.args.add is not None or self.args.delete is not None:
            sys.exit(self.modify_urls(self.jobs, self.args.urls, self.args.add, self.args.delete))

    def load_jobs_config(self):
        if os.path.isfile(self.args.urls):
            jobs = UrlsYaml(self.args.urls).load_secure()
        else:
            logger.warn('No jobs file found')
            jobs = []

        return jobs

    def load_hooks_modules(self):
        if os.path.exists(self.args.hooks):
            imp.load_source('hooks', self.args.hooks)

    def check_jobs_available(self):
        if not os.path.isfile(self.args.urls) and not self.args.edit and not self.args.add:
            print("""
            You need to create {urls_yaml} in order to use {pkgname}.
            Use "{pkgname} --edit" to open the file with your editor.
            """.format(urls_yaml=self.args.urls, pkgname=self.config.pkgname))
            sys.exit(1)

    def check_urlwatch_config(self):
        if not os.path.exists(self.args.config):
            ConfigStorage.write_default_config(self.args.config)
            print("""
            A default config has been written to {config_yaml}.
            Use "{pkgname} --edit-config" to customize it.
            """.format(config_yaml=self.args.config, pkgname=self.config.pkgname))

    def check_urlwatch_dir(self):
        if not os.path.isdir(self.config.urlwatch_dir):
            os.makedirs(config.urlwatch_dir)
            print("""
            Created directory: {urlwatch_dir}
            """.format(urlwatch_dir=self.config.urlwatch_dir))

    def init_loggers(self):
        if self.args.verbose:
            root_logger = logging.getLogger('')
            console = logging.StreamHandler()
            console.setFormatter(logging.Formatter('%(asctime)s %(module)s %(levelname)s: %(message)s'))
            root_logger.addHandler(console)
            root_logger.setLevel(logging.DEBUG)
            root_logger.info('turning on verbose logging mode')

    def __init__(self, config, args):

        self.config = config
        self.args = args
        self.init_loggers()
        self.migration_manager = MigrationManager(self.config, self.args)

    def main(self):

        logger.info('Using %s as URLs file', self.args.urls)
        logger.info('Using %s for hooks', self.args.hooks)
        logger.info('Using %s as cache directory', self.args.cache)

        self.check_urlwatch_dir()
        self.check_urlwatch_config()

        if self.args.edit_config:
            sys.exit(edit_yaml(self.args.config, ConfigStorage))

        self.migration_manager.migrate_jobs_to_urlwatch_2x()

        self.check_jobs_available()
        self.load_hooks_modules()
        self.jobs = self.load_jobs_config()

        self.cache_storage = self.migration_manager.migrate_cache_to_urlwatch_2x(self.jobs)

        self.config = ConfigStorage(self.args.config)
        self.report = Report(self.config.config)

        self.handle_actions()

        self.execute_jobs()

        # Output everything
        self.report.finish()

        # Close cache
        self.cache_storage.close()


if __name__ == '__main__':

    parser = argparse.ArgumentParser(description=urlwatch.__doc__,
                                     formatter_class=argparse.RawDescriptionHelpFormatter)

    parser.add_argument('--version', action='version', version='%(prog)s {}'.format(urlwatch.__version__))
    parser.add_argument('-v', '--verbose', action='store_true', help='show debug output')

    group = parser.add_argument_group('files and directories')
    group.add_argument('--urls', metavar='FILE', help='read job list (URLs) from FILE', default=urlwatch_config.urls_yaml)
    group.add_argument('--config', metavar='FILE', help='read configuration from FILE', default=urlwatch_config.config_yaml)
    group.add_argument('--hooks', metavar='FILE', help='use FILE as hooks.py module', default=urlwatch_config.hooks_py)
    group.add_argument('--cache', metavar='FILE', help='use FILE as cache database', default=urlwatch_config.cache_db)

    group = parser.add_argument_group('job list management')
    group.add_argument('--list', action='store_true', help='list jobs')
    group.add_argument('--add', metavar='JOB', help='add job (key1=value1,key2=value2,...)')
    group.add_argument('--delete', metavar='JOB', help='delete job by location or index')

    group = parser.add_argument_group('interactive commands ($EDITOR/$VISUAL)')
    group.add_argument('--edit', action='store_true', help='edit URL/job listL')
    group.add_argument('--edit-config', action='store_true', help='edit configuration file')
    group.add_argument('--edit-hooks', action='store_true', help='edit hooks script')

    group = parser.add_argument_group('miscellaneous')
    group.add_argument('--features', action='store_true', help='list supported jobs/filters/reporters')
    group.add_argument('--gc-cache', action='store_true', help='remove old cache entries')

    urlwatch = Urlwatch(urlwatch_config, parser.parse_args())
    urlwatch.main()
